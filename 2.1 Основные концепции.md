#programming 
# Основные понятия
> **Процесс** - совокупность машинных команд и данных, которая обрабатывается в рамках вычислительной системы и обладает правами на использование некоторого набора ресурсов.

> Ресурсы могут принадлежать только одному процессу, либо ресурсы могут разделяться между процессами - **разделяемые ресурсы.**

## Выделение ресурсов процессу
- *Предварительная декларация* - до начала выполнения
	- Заказ предустановки или организации доступа к некоторым информационным ресурсам или данным.
	- Может заранее сообщаться, какие виртуальные страницы доступны процессу.
- *Динамическое пополнение* списка принадлежащих процессу ресурсов
	- Ресурс выделяется по запросу, динамически.
	- Например использование ресурса в Linux или Windows системах.
## Жизненный цикл процесса
> Основной из задач ОС является поддержание жизненного цикла процесса.
> 
- *Типовые этапы обработки процесса в системе:*
	- Образование (порождение) процесса
	- Обработка (выполнение) процесса
	- Ожидание постановки на выполнение (по тем или иным причинам)
		- Например, [[1.2 Основы архитектуры вычислительной системы#Page fault в страничной организации памяти|page fault]]
	- Завершение процесса
		- Тоже процесс, т.к. возвращение ресурсов в системный пул не моментально.
# Модельная ОС
> 1. **Буфер ввода процессов (БВП)** - пространство, в котором размещаются и хранятся сформированные процессы с момента их образования, до момента начала выполнения.
> 2. **Буфер обрабатываемых процессов (БОП)** - буфер для размещения процессов, находящихся в системе в мультипрограммной обработке.

- Буфер ввода процессов организуется как приоритетная очередь.

## Модель пакетной однопроцессной системы
0. *Ожидание начала обработки*
	- Поступление процесса в БВП.
1. Обработка ЦП
	-  *Начало обработки* процесса (БВП -> БОП).
2. *Завершение*
	- Освобождение системных ресурсов.
	- В данном случае, процесс недлительный.
## Модель пакетной мультипроцессной системы
![[Pasted image 20251009110457.png]]
- По завершении обмена (2) происходит прерывание, с переходом к связанному процессу.
- Завершение происходит при успешном выполнении процесса или при фатальном прерывании (деление на ноль и т.п.).
## Модель ОС с разделением времени
![[Pasted image 20251009111022.png]]
- Разница в наличии [[1.4 Основы архитектуры операционных систем#Системы разделения времени|кванта времени]]. По его истечении (1) переходит в (3).

> Есть также модификация: ![[Pasted image 20251009111300.png]]
> Свопинг используется в случае, если не хватает физической оперативной памяти.

- Процессы с незавершёнными обменами не выгружаются из физической оперативной памяти

## Полновесные процессы Vs Нити
> 1. **"Полновесные" процессы** - процессы, выполняющиеся внутри защищённых участков оперативной памяти.
> 2. **"Легковесные" процессы** (нити, *threads* или сопрограммы) - работают в мультипрограммном режиме одновременно с активировавшим их полновесным процессом и использует его виртуальное адресное пространство. (активируются полновесным процессом на принадлежащем ему участке ОП и не защищены друг от друга.)

- В одном полновесном процессе может быть *одна или несколько нитей.* 
	- В этом случае нить работает в защищённом адресном пространстве. ![[Pasted image 20251009112051.png]]
	- В этом случае нить не защищена от остальных нитей. ![[Pasted image 20251009112026.png]]

- Нить это, например, выполняемая программа.
- На примере аудитории:
	- Полновесный процесс - аудитория
	- Нити - люди на лекции (независимые процессы, которые могут помешать друг другу)
- В языках:
	- Threads в python
	- Go в [[Golang|golang]]
## Контекст процесса 
> **Контекст процесса** - совокупность данных, характеризующих актуальное состояние процесса.

- *Пользовательская составляющая* - текущее состояние программы (совокупность машинных команд и данных, размещённых в ОЗУ)
- *Системно-аппаратная составляющая:*
	- Информация идентификационного характера (PID процесса, PID "родителя"...)
	- Информация о содержимом регистров, настройках аппаратных интерфейсов, режимах работы процессора, настройках и использовании виртуальной памяти и т.п.
	- Информация, необходимая для управления процессом (состояние процесса, приоритет) (расширенная копия таблицы страниц)
# Процесс UNIX
> **Процесс в UNIX**  - объект, зарегистрированный в таблице процессов UNIX.
- Процесс:
	1. Объект, зарегистрированный в таблице процессов ОС
		- Любая запись в таблице - процесс.
		- Размер таблицы процессов ОС определяет максимальное количество процессов.
	2. Объект, порождённый системным вызовом [[2.1 Основные концепции#Fork() - Создание нового процесса|fork()]]

## Идентификатор процесса (PID)
![[Pasted image 20251009113322.png]]
- *Пользовательская составляющая* - код и данные процесса (в адресном пространстве процесса).
- *Системная составляющая* - всё то, что хранит операционная система о процессе в своих таблицах.
- *Аппаратная составляющая* - содержимое регистров, состояние процесса, состояние аппаратуры в динамике. (актуально *только в момент исполнения* процесса)

## Контекст процесса
### Пользовательская составляющая
![[Pasted image 20251009113635.png]]
- *Сегмент данных* - область памяти
	- Статические данные
	- Разделяемая память
	- Динамическая память - куча (heap)
		- Стек
			- Автоматические переменные - локальные переменные.
			- Фактические параметры в функциях (реализуются в стеке как матрёшка)
		- Динамическая память
- *Сегмент кода* 
	- Не меняется
	- Один сегмент кода может использоваться *несколькими процессами* (например несколько процессов, использующих одну и ту же программу)

### Системная составляющая
- *Идентификатор* процесса + идентификатор родительского процесса (PID, PPID)
- *Состояние* процесса
- *Приоритет* процесса (чем дольше работает процесс, тем меньше его приоритет)
- Реальный и эффективный *идентификаторы пользователя-владельца*
	- Идентификатор пользователя, сформировавшего процесс (пользователь, запустивший файл).
	- *Эффективный идентификатор - идентификатор владельца* файла, который был запущен как процесс (определяет права процесса).
- Реальный и эффективный *идентификатор группы,* к которой принадлежит владелец
- Список областей памяти
- *Таблица открытых файлов* процесса
	- Таблица, в которой находятся файловые дескрипторы используемых файлов (метод open())
- информация об установленной реакции на тот или иной [[2.4 Реализация процессов в ОС UNIX#Сигналы|сигнал]]
- информация о [[2.4 Реализация процессов в ОС UNIX#Сигналы|сигналах]], ожидающих доставки в данный процесс
- Сохранённые *значения аппаратной составляющей*

# Fork() - Создание нового процесса 
```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

- При удачном завершении возвращается:
	- сыновнему процессу *значение 0* (значит, мы находимся в сыновьем процесссе)
	- родительскому процессу *PID порождённого процесса*
- При неудачном завершении (создания) *возвращается -1*, код ошибки устанавливается в переменной *errno*
	- Такое может случиться, если таблица процессов заполнена.
	- Либо в иных системных структурах недостаточно места.

- Заносится новая запись в таблицу процессов
- Новый процесс получает уникальный идентификатор
- Создание контекста для нового (сыновьего) процесса
> Задание: посмотреть errno.h переменная с перечисляемыми значениями (коды и смысл кодов отказа)

## Составляющие контекста, наследуемые при вызове fork()
- Идентификатор процесса (*PID*)
- Идентификатор родительского процесса (*PPID*)
	- А что, если PPID завершится, а PID останется?
	- PPID будет ссылаться на новый, несвязанный процесс
	- Для таких процессов существует процесс с `PID = 1`
- Сигналы, ждущие доставки в родительский процесс
- Время посылки ожидающего сигнала, установленное системным вызовом alarm()
- Блокировки файлов, установленные родительским процессом
- Работа с унаследованными открытыми файлами отличается от работы с открытыми процессом файлами.
## Схема создания нового процесса
> Не лекциях рассматриваем успешные веточки, где всё срабатывает. Следует обрабатывать *все возможные сценарии.*

- `PID = 2757`
```c
main() {
	int i = 0, pid;
	...
	if ((pid = fork()) > 0) {
		i++;
		...
	} else {...}
}
```
- Родитель: выполняются операторы в if-секции.
	- `PID = 2757`
- Потомок: выполняются операторы в else-секции.
	- `PID = NNNN`
	- Контекст нового процесса принадлежит полностью ему. Переменная i теперь есть и в `2757`, и в `NNNN`
### Пример
```c
/* PID 2757; PPID PPPP */
int main (int argc, char **argv) {
	printf("PID = %d; PPID = %d \n", getpid(), getppid());
	fork();
	printf("PID = %d; PPID = %d \n", getpid(), getppid());
	return 0;
}
```
- Часть вариантов выполнения:
	1. 
		- PID = 2757; PPID = PPPP
		- PID = 2757; PPID = PPPP
		- *PID = NNNN; PPID = 2757*
	2. 
		- PID = 2757; PPID = PPPP
		- *PID = NNNN; PPID = 2757*
		- PID = 2757; PPID = PPPP
	3. 
		- PID = 2757; PPID = PPPP
		- PID = 2757; PPID = PPPP
		- *PID = NNNN; PPID = 1*
> Процессы могут завершаться в разном порядке. Курсивом выделен вывод сыновьего процесса.

> Дома перебрать все возможные варианты

# Exec() - Семейство системных вызовов
```c
#include <unistd.h>

int excel (const char *path, char *arg0, ..., char*argn, NULL);
```
> Передаём имя существующего доступного исполняемого файла, код которого заменит [[2.1 Основные концепции#Пользовательская составляющая|тело текущего процесса.]]
> 
- `path` - имя файла, содержащего исполняемый код программы. (полное имя)
- `arg0` - имя файла, содержащего вызываемую на выполнение программу. (название файла, но стоит проверить в `man`)
- `arg1`-`argn` - аргументы программы, передаваемые ей при вызове.
> Список параметров должен заканчиваться на `NULL`.
## Пример запуска команды `ls -l`
PID = 2760
```c
main () { ...
	execl ("bin/ls", "ls", "-l", NULL)
	...
}
```
-> PID = 2760
```c
int main (int argc, char** argv) {
	// ls implementation
}

// argc = 2
// argv[0] == "ls"
// argv[1] == "-l"
// argv[2] == 0
```
> Если почитать `man exec`, можно также найти команду `extern int execv(const char *__path, char *__argv[])`. Exec vector адаптирована под использование с argv.

- При использовании `execl()` сохраняется:
	- Идентификатор процесса - PID
	- Идентификатор родительского процесса - PPID
	- Таблица дескрипторов файлов (за исключением специальным образом открытых)
	- ...
- Изменяются:
	- Режимы обработки [[2.4 Реализация процессов в ОС UNIX#Сигналы|сигналов]]
	- [[2.1 Основные концепции#Системная составляющая|Эффективные идентификаторы]]

## Поймать ошибку `execl()`
```c
#include <unistd.h>
int main (int argc, char **argv) {
	...
	execl("bin/ls", "ls", "-l", NULL);
	// or execlp("ls", "ls", "-l", NULL)
	printf("Print if something goes wrong.\n")
	...
}
```

- `execl` может завершиться неуспешно в случае, если:
	- Недостаточно прав
	- Файл не является исполняемым (в начале файла нет общего кода исполняемых файлов)

## Fork-exec схема
> Создаётся новый процесс, который становится `ls`. Исходный процесс продолжает выполнение в ветке `else`.
- PID = 2757
```c
main () {
	if ((pid = fork()) == 0) {
		execl("/bin/ls", "ls", "-l", NULL);
	} else {...}
}
```

- `if () {...}` -> fork() -> PID = XXXX
```c
int main (int argc, char* argv[]) {
	// ls implementation
}
```

- `else {...}` -> PID = 2757
```c
else {...}
```

# Exit() - Завершение процесса
- Системный вызов `_exit()`
- Выполнение оператора C `return`, входящего в состав `main()`
- Реакция на получение [[2.4 Реализация процессов в ОС UNIX#Сигналы|определённых сигналов]]

> Процесс завершается не моментально. (переходит в состояние зомби)

1. Корректно освобождаются ресурсы (закрываются все дескрипторы файлов, освобождаются сегмент кода и сегмент данных процесса и прочее)
2. Освобождается большая часть контекста процесса, однако сохраняется *запись в таблице процессов* и часть контекста, в которой хранится статус завершения и статистика выполнения процесса.
3. Все сыновьи процессы, чьи родители завершились, усыновляются процессом с номером `1`.
4. Сыновий процесс завершается -> предку передаётся сигнал `SIGCHLD`. Обычно он игнорируется, по умолчанию.

```C
#include <unistd.h>
	void _exit(int status); // system call
```
- Status:
	- 0 - успешное завершение
	- $\neq$ 0 - код ошибки



`exit()` - Функция из библиотеки. Корректно сбрасывает буферы библиотечного уровня.
`_exit()` - Системный вызов. Моментально завершает вызвавший процесс. Все файловые дескрипторы закрываются. 


# Wait() - Ожидание завершения потомка
```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait (int *status)
```
> Кратко: `wait(int *__stat_loc)` ждёт перехода в состояние зомби любого сыновьего процесса.
> 
> После передачи информации о завершении предку, все структуры, связанные с процессом-зомби освобождаются. Удаляется запись из таблицы процессов.
1. Если к моменту обращения к `wait` *какие-то* сыновние процессы находятся *в состоянии зомби,* `wait` вернёт PID одного из этих процессов и данный процесс удалится из системы.
2. Если у процесса имеются *только работающие сыновние процессы*, отцовский процесс будет блокирован до момента перехода любого из сыновних в состояние зомби.
3. Если у процесса нет сыновних процессов (как работающих, так и зомби), то, при обращении к `wait`, будет получен код `-1`
4. Если процесс при выполнении `wait` в данный процесс придёт [[2.4 Реализация процессов в ОС UNIX#Сигналы|сигнал]], то будет получен код `-1`
- `status` содержит:
	- В старшей части - код завершения процесса потомка (пользовательский код завершения процесса/[[2.4 Реализация процессов в ОС UNIX#Сигналы|номер сигнала]])
	- В младшей части - индикатор причины завершения процесса-потомка, устанавливаемый ядром UNIX
> Существует также `waitpid(__pid_t __pid, int *__stat_loc, int __options)`, ожидающий завершения конкретного процесса.

>  `wait(&wstatus)` $\equiv$ `waitpid(-1, &wstatus, 0)`

## Пример использования
```c
#include <stdio.h>
int main(int argc, char **argv) {
	int i;
	for (i=1; i<argc; i++) {
		if (fork() > 0) {
			wait(&status);
			printf("process father\n")
			continue;
		}
		execlp(argv[i], argv[i], 0);
		exit(0);
	}
}
```
> Даём на ввод `file prog1 prog2 prog3` и получаем "process father" по выполнении каждой указанной программы.