#lecture #programming
### Definitions
> ОП - оперативная память.

> банки - аппаратно созданные слои ОП.

### Lecture
#### Конвеер ЦП
1. *чтение команды*
2. дешифратор
3. *чтение 1 арг*
4. *чтение 2 арг*
5. оперативная память
6. *результат*
(выделенные требуют обращения в ОП)
> Для эффективной работы конвеера необходимо, чтобы ОП могла обрабатывать несколько запросов одновременно.
> => Ввести параллелизм в работу ОП.
#### Расслоение ОП
- ОП аппаратно разделяется на слои (банки), которые работают параллельно и независимо друг от друга.
- Соседние ячейки ОП попадают в разные банки.
- *Напирмер*,  пусть 16 банков. Тогда разделение будет происходить по последнему разряду:
	  1. 00..00, 00..10, ..., 00..F0
	  2. 00..01, 00..11, ..., 00..F1
	  3. ...
```
X db 70 dup (?)
inc x
inc x + 1
inc x + 2

; inc выполняются одновременно т.к. x - в одном банке,
; x + 1 и x + 2 - в других
```
#### Кэш-память
##### Идея использования кэш-памяти
> Скорость ЦП >> скорость обмена с ОП
> => Во избежание простоев нужно ускорить обмен между ЦП и ОП.
##### Возможность
Практика показала, что обращение к ОП подчиняется закономерностям.
1. Принцип пространственной локализации.
	- если в момент t было обращение к ячейке ОП\[A], в момнет t + 1 будет обращение к ОП\[A - 1] или ОП\[A + 1]. (обработка массивов; последовательность команд программы)
2. Принцип временной локализации.
	- В момент t было обращение к ОП\[A], в t + 1 или t + 2 произойдёт обращение к ней же. (реультат одной команды - входные данные для следующей)
##### Идея кэш-памяти
- Встроить между процессором и оперативной памятью небольшую быструю память (кэш).
- В ней храним данные, которые часто исользуются процессором.
- ЦП почти всё время работает с кэш и только в редких случаях обращается к ОП.
##### Работа кэш
###### 1) Чтение
```
if данные в кэш then
	ЦП <- кэш
else 
begin
	кэш <- ОП
	ЦП <- кэш
end

; 1) else медленнее, чем ЦП <- ОП
; 2) "Промах кэш" 
; Организация работы с кэш -> минимизировать количество промахов.
```
###### 2) Зпись
- Одна и та же ячейка хранится в 2х экземплярах. В ОП и в кэш.
- Содержимое у копий ячейки должно быть одинкаово.
- Когерентность кэш и ОП: ячейки хранят одинакоые значения и в кэш, и в ОП. То есть содержимое кэш и ОП согласованно.
*Способы записи:*
1) Сквозная запись
	- прозрачный алгоритм
	- медленно
```
if ячейка в кэш then
begin
	 ЦП -> кэш
	 кэш -> ОП
end
else ЦП -> ОП
```
2) Обратная запись
	- данные копируются кэш -> ОП только при замене элементов в кэш.
```
ЦП (A1) -> кэш (в ОП не пишем)
ЦП (А2) <- кэш, промах
	1. кэш -A1-> ОП
	2. кэш <-A2- ОП
(затем ЦП <-A2- кэш)
; в кэш (A1) заменилось на (A2)
```
#### Организация кэш-памяти
- Принцип 1 => Обмен кэш <-> ОП блоками из подряд идущих ячеек.
- На логическом уровне:
	- Кэш состоит из строк (элементов)
	- *ячейка 1|ячейка 2|\*\*\*| ячейка 16*
	- Пусть строка из 16 ячеек.
	- Смещение ячейки внутри строки - 0, 1, ..., 0Fh
	- Тэг: ячейки с какими адресами ОП находятся в строке.
	- По адресу ячейки (ОП) определяется, где ячейка может находиться в кэш.
	- Обращение:
		- Адрес ОП -> местоположение в кэш
#### Способы организации
##### Кэш прямого отображения
- Каждая строка имеет свой номер и тэг.
- Адрес ячейки: *N строки|тэг&тэг|смещение в строке* (4 bit)
	- A1 = 3571h, A2 = 3575h
- Пример: (проверка, если ли ячейка в кэш)
	- A3 = 3578h
	1) выделяем N строки (=3); тэг (=57)
	2) проверка тэг строки 3 в кэш =57.
	   если да, ячейка есть в кэш
	- A4 = 3408  - нет в кэш ("промах кэш")
> тэг нужен для определения наличия ячейки в кэш.
##### Ассоциативная кэш-память
- Состоит из строк.
- Адрес ячейки: *тэг&тэг&тэг|смещение в строке* (4 bit)
- Пример: (проверка, есть ли ячейка в кэш)
	- A3 = 3578
	1) выделяем из A тэг и смещение
	2) параллельно сравниваем все тэги сток кэша с 357.
	   если есть совпадение, ячейка есть в кэш
	   иначе - "промах кэш".
> (процесс параллельного сравнения трудно организовать, поэтому такую память трудно сделать большой.)
##### Множественно-ассоциативная
- Кэш состоит из блоков (обычно 4, но в нашем применении будет 16 блоков).
- Адрес ячейки: *N блока|тэг&тэг|смещение в строке* (4 bit)
- Пример: (проверка, есть ли ячейка в кэш)
	- A3 = 3578
	1) выделение N блока  (=3), тэга (=57)
	2) параллельное сравнение тэгов строк блока N3 с тэгом 57.
	   если есть совпадение, ячейка есть в кэш
	   если нет - "промах кэш"
> используется в актуальных архитектурах
#### Проблема в случае промаха
- Кэш <- ОП
- Хотим записать в кэш 3F54, а все строки блока N3 заняты.
- Какой элемент вытеснить из кэш?
- Решение должно минимизировать общее количество промахов.
-  *Подходы:*
	1) самую старую строку
	2) к которой было меньше всего обращений
> Команды перехода вызывают промах кэш, приходится подгружать новые данные в кэш => замедление работы программы.

> Каждый сигнали прерывания заставляет подрузить кэш прерывания, затем загрузить информацию обратно. 2 промаха -> резкое замедление работы программы.
#### Несколько уровней кэш
- скорость ЦП >> скорость кэш >> скорость ОП
- ЦП <-> кэш 1го уровня <-> кэш 2го уровня <-> ОП
- скорость ЦП >  скорость 1 > скорость 2 >  скорость ОП
- объём 1 < объём 2 < объём ОП
- кэш 1го уровня
	- кэш команд
	- кэш данных